namespace Catalogue

open Chessie.ErrorHandling
open Fake
open Newtonsoft.Json
open Newtonsoft.Json.Linq
open System
open System.Dynamic
open System.IO
open System.Linq
open System.Text
open System.Text.RegularExpressions
open WebMarkupMin.Core.Minifiers

module Server = 
    open Suave
    open Suave.Files
    open Suave.Operators
    open Suave.Sockets
    open Suave.Sockets.AsyncSocket
    open Suave.Sockets.Control
    open Suave.Utils
    open Suave.Web
    open Suave.WebSocket
    open System.Net
    
    let refreshEvent = new Event<_>()
    
    /// Taken from FsReveal
    /// https://github.com/ademar/FsReveal/blob/0a5eb5a30edd54011ebe2bd395403558bce1ee7d/src/FsReveal/template.html
    let reloadScript = """
<script type="text/javascript">
    function init()
    {
        websocket = new WebSocket("ws://localhost:8080/websocket");
        websocket.onmessage = function(evt) { location.reload(); };
    }
    window.addEventListener("load", init, false);
</script>
</head>
"""
    
    let startWebServer (outputFolder) = 
        printInfo "Starting webserver: %s" (outputFolder)
        let serverConfig = 
            { defaultConfig with homeFolder = Some(outputFolder)
                                 bindings = [ HttpBinding.mk HTTP IPAddress.Loopback 8080us ] }
        
        // Taken from FsReveal project
        let socketHandler (webSocket : WebSocket) = 
            fun cx -> 
                socket { 
                    while true do
                        let! refreshed = Control.Async.AwaitEvent(refreshEvent.Publish) 
                                         |> Suave.Sockets.SocketOp.ofAsync
                        do! webSocket.send Text (ASCII.bytes "refreshed") true
                }
        
        let browseStaticFiles ctx = 
            async { 
                let local = ctx.request.url.LocalPath.Substring(1)
                
                let file = 
                    if local.EndsWith("/") then local + "index.html"
                    else if local.Contains(".") then local
                    else sprintf "%s/index.html" local
                return! browseFileHome file ctx
            }
        
        let app = 
            choose 
                [ Filters.path "/websocket" >=> handShake socketHandler
                  
                  Writers.setHeader "Cache-Control" "no-cache, no-store, must-revalidate" 
                  >=> Writers.setHeader "Pragma" "no-cache" >=> Writers.setHeader "Expires" "0" >=> browseStaticFiles ]
        
        startWebServerAsync serverConfig app
        |> snd
        |> Async.Start
        printInfo "Started server on port:%i" 8080

module Build = 
    let private htmlMinifier = new HtmlMinifier()
    
    let minifyHtml (page : FrontMatter) (content) = 
        let minified = htmlMinifier.Minify(content)
        if minified.Errors.Count = 0 && minified.Warnings.Count = 0 then minified.MinifiedContent
        else 
            printLine()
            printWarning "Page:%s. Encountered HTML minification errors" page.Id
            minified.Errors 
            |> Seq.iter (fun e -> printWarning "Line:%i, Column:%i:Message:%s" e.LineNumber e.ColumnNumber e.Message)
            minified.Warnings 
            |> Seq.iter (fun e -> printWarning "Line:%i, Column:%i:Message:%s" e.LineNumber e.ColumnNumber e.Message)
            printLine()
            content
    
    let headRegex = new Regex("</head>", RegexOptions.Compiled ||| RegexOptions.IgnoreCase)
    
    /// Generate HTML page from the markdown
    (*
    This involves the following steps:
     1 : Parse the markdown for special block tags like render, include etc
         and process them.
     2 : Convert the content to HTML using the markdown parser.
     3 : Render the handlebars layout with the correct context.
    *)
    let generatePage context index page = 
        let pageCount = context.Pages.Length - 1
        BlockParsers.processPreMarkDownBlocks context page
        let content = page.Content.ToString()
        // Copy over the markdown generated by running through the pre markdown
        // render process as it will be used for generating search index.
        page.MarkDown.Clear().Append(content) |> ignore
        let renderResult = 
            if page.NoMarkdown then 
                { RenderedMarkDown = content
                  Headings = [||] }
            else context.JSEngine.MarkdownParser.Render(page.Id, content)
        // Update the content so that post markdown process could use the HTML
        page.Content.Clear().Append(renderResult.RenderedMarkDown) |> ignore
        BlockParsers.processPostMarkDownBlocks context page
        let pageContext = context.HandlebarsContext
        pageContext.["content"] <- JToken.FromObject(page.Content.ToString())
        pageContext.["headings"] <- JArray.FromObject(renderResult.Headings, Json.serializer)
        pageContext.["page"] <- page.ToJobject()
        if index > 0 && index <> -1 then pageContext.["previouspage"] <- context.Pages.[index - 1].ToJobject()
        else pageContext.Remove("previouspage") |> ignore
        if index < pageCount && index <> -1 then pageContext.["nextpage"] <- context.Pages.[index + 1].ToJobject()
        else pageContext.Remove("nextpage") |> ignore
        pageContext.["editmelink"] <- JToken.FromObject(context.Settings.RepositoryEditMeLink + page.RelativePath)
        let mutable renderedOutput = context.JSEngine.HandleBars.Transform(page.Layout, pageContext)
        if context.BuildTasks.LiveReload then 
            renderedOutput <- headRegex.Replace(renderedOutput, Server.reloadScript, 1)
        let targetFile = Links.getTargetFile page.Link context.Settings.BuildOutput
        Directory.CreateDirectory(Path.GetDirectoryName(targetFile)) |> ignore
        File.WriteAllText(targetFile, minifyHtml page renderedOutput)
    
    /// Generates HTML pages from the markdown. 
    let generatePages (context : Context) = 
        context.Pages |> Array.iteri (fun index page -> generatePage context index page)
        context
    
    /// Registers all the partials from the partials folder    
    let registerAllPartials (context : Context) = 
        for input in context.Partials do
            context.JSEngine.HandleBars.RegisterPartial(input.Key, input.Value) |> ignore
            /// Register each partial as a top level template so that it can be used from render block
            context.JSEngine.HandleBars.Compile(input.Key + "_partial", input.Value) |> ignore
        context
    
    /// Compiles all the layouts from the layouts folder
    let compileAllLayouts (context : Context) = 
        context.Layouts |> Seq.iter (fun input -> context.JSEngine.HandleBars.Compile(input.Key, input.Value) |> ignore)
        context
    
    /// Generates LUNR search index
    let generateSearchIndex (context : Context) = 
        if context.BuildTasks.EnableSearch then 
            context.Pages
            |> Array.filter (fun page -> not page.ExcludeFromSearchIndex)
            |> Array.mapi (fun id page -> 
                   { Id = id
                     Href = page.Permalink
                     Body = page.MarkDown.ToString() |> BlockParsers.stripForSearch
                     Title = page.Title })
            |> context.JSEngine.Lunr.CreateIndex
            |> fun i -> File.WriteAllText(context.Settings.BuildOutput +/ "index.json", i)
        context
    
    let private extractMainRegex = 
        new Regex(@"<main[\w\W]+?>([\w\W]+)<\/main>", RegexOptions.Compiled ||| RegexOptions.CultureInvariant)
    
    /// Generates a single page document from all the docs pages by extracting 
    /// content between main tags and appending it together. After the consolidated
    /// text is generated then it is rendered using the all template. This allows
    /// user to generate custom chapter wise TOC if required.
    let generateSinglePageDoc (context : Context) = 
        if context.BuildTasks.GenerateSinglePageDoc then 
            let consolidateMarkDown = new StringBuilder(4096)
            context.Pages
            |> Array.filter (fun page -> not page.ExcludeFromSingleFile)
            |> Array.iter 
                   (fun page -> 
                   let targetFile = Links.getTargetFile page.Link context.Settings.BuildOutput
                   let m = extractMainRegex.Match(File.ReadAllText(targetFile))
                   match m.Success with
                   | true -> consolidateMarkDown.Append(m.Groups.[1].Value) |> ignore
                   | _ -> 
                       printWarning 
                           "Single document generation warning: <main></main> section not present in the page. Id: %s" 
                           page.Id)
            match Array.tryFind (fun (p : FrontMatter) -> p.Id = "all") context.Pages with
            | Some(fm) -> 
                fm.Content.Clear().Append(consolidateMarkDown) |> ignore
                fm.MarkDown.Clear().Append(consolidateMarkDown) |> ignore
                generatePage context -1 fm
            | None -> 
                printWarning 
                    "Cannot locate a page with id: all which can be used to generate single page documentation."
        context
    
    /// Compiles the SCSS file to CSS
    let generateCss (context : Context) = 
        let filePath = context.Root.Path +/ context.Settings.MainCssFile
        
        let outputPath = 
            let outputFileName = 
                let mainCssFolder = Path.GetDirectoryName(context.Settings.MainCssFile)
                let fn = Path.GetFileNameWithoutExtension(context.Settings.MainCssFile)
                if fn.StartsWith("_") then mainCssFolder +/ fn.Substring(1) + ".css"
                else mainCssFolder +/ fn + ".css"
            context.Settings.BuildOutput +/ outputFileName
        
        let outputDir = Path.GetDirectoryName(outputPath) |> ensureDirectory
        if File.Exists filePath then 
            if 0 
               <> ExecProcess (fun info -> 
                      info.FileName <- rootPath +/ "libsass/sassc.exe"
                      info.Arguments <- sprintf "--style compressed %s %s" filePath outputPath) 
                      (TimeSpan.FromSeconds(45.0))
            then printError "Sass compilation failed."
        context
    
    let jsInsertRegex = 
        new Regex("\/\* @insert ([\w-_.]+) \*\/", RegexOptions.Compiled ||| RegexOptions.CultureInvariant)
    
    /// Compiles the JS file
    let generateJs (context : Context) = 
        let filePath = context.Root.Path +/ context.Settings.MainJsFile
        let mainJsFileFolder = Path.GetDirectoryName(filePath)
        
        let outputPath = 
            let mainJsFolder = Path.GetDirectoryName(context.Settings.MainJsFile)
            
            let outputFileName = 
                let fn = Path.GetFileName(context.Settings.MainJsFile)
                if fn.StartsWith("_") then mainJsFolder +/ fn.Substring(1)
                else mainJsFolder +/ fn
            context.Settings.BuildOutput +/ outputFileName
        
        let outputDir = Path.GetDirectoryName(outputPath) |> ensureDirectory
        if File.Exists filePath then 
            let content = new StringBuilder(File.ReadAllText(filePath))
            jsInsertRegex.Matches(content.ToString())
            |> Seq.cast
            |> Seq.map (fun (m : Match) -> (m.Groups.[0].Value, m.Groups.[1].Value))
            |> Seq.iter (fun (matchedText, insertFileName) -> 
                   if File.Exists(mainJsFileFolder +/ insertFileName) then 
                       content.Replace(matchedText, File.ReadAllText(mainJsFileFolder +/ insertFileName)) |> ignore
                   else printError "Javascript file marked for insertion does not exist. Insert tag:%s" matchedText)
            if context.BuildTasks.MinifyJS then 
                let jsMinifier = new CrockfordJsMinifier()
                let codeMinResults = jsMinifier.Minify(content.ToString(), false)
                if codeMinResults.Errors.Count = 0 && codeMinResults.Warnings.Count = 0 then File.WriteAllText(outputPath, codeMinResults.MinifiedContent)
                else 
                    printError "Encountered JS minification errors."
                    codeMinResults.Errors 
                    |> Seq.iter 
                           (fun e -> printError "Line:%i, Column:%i:Message:%s" e.LineNumber e.ColumnNumber e.Message)
                    codeMinResults.Warnings 
                    |> Seq.iter 
                           (fun e -> printError "Line:%i, Column:%i:Message:%s" e.LineNumber e.ColumnNumber e.Message)
                    File.WriteAllText(outputPath, content.ToString())
            else File.WriteAllText(outputPath, content.ToString())
        context
    
    /// Generate simple text based sitemap.txt
    let generateSiteMap (context : Context) = 
        if context.BuildTasks.GenerateSiteMap then 
            context.Pages
            |> Array.map (fun page -> 
                   let temp = sprintf "%s/%s" context.Settings.SiteUrl page.Link
                   temp.Replace("//", "/").Replace("//", "/"))
            |> fun i -> File.WriteAllLines(context.Settings.BuildOutput +/ "sitemap.txt", i)
        context
    
    /// Copy assets from the input folder to the build folder
    let copyAssets (context : Context) = 
        let rec directoryCopy srcPath dstPath = 
            if not <| System.IO.Directory.Exists(srcPath) then 
                let msg = System.String.Format("Source directory does not exist or could not be found: {0}", srcPath)
                raise (System.IO.DirectoryNotFoundException(msg))
            if not <| System.IO.Directory.Exists(dstPath) then System.IO.Directory.CreateDirectory(dstPath) |> ignore
            let srcDir = new System.IO.DirectoryInfo(srcPath)
            for file in srcDir.GetFiles() do
                let temppath = System.IO.Path.Combine(dstPath, file.Name)
                // Skip all files starting with _
                if not <| file.Name.StartsWith("_") then file.CopyTo(temppath, true) |> ignore
            for subdir in srcDir.GetDirectories() do
                /// Skip directories which starts with '_'
                if not <| subdir.Name.StartsWith("_") then 
                    let dstSubDir = System.IO.Path.Combine(dstPath, subdir.Name)
                    directoryCopy subdir.FullName dstSubDir
        directoryCopy context.Root.Path context.Settings.BuildOutput
        context
    
    let buildSteps =
        [|
            (registerAllPartials, "Register all partials")
            (compileAllLayouts, "Compile all layouts")
            (generateCss, "Process CSS")
            (generateJs, "Process JavaScript")
            (generatePages, "Generate Pages")
            (generateSearchIndex, "Generate Search Index")
            (generateSinglePageDoc, "Generate Single page document")
            (generateSiteMap, "Generate site-map")
            (copyAssets, "Copy assets")
        |]

    /// Build the whole site from the generated context
    let build (rootFolder : RootDirectory) (context : Option<Context>) (args : CommandLineArgs) = 
        let settings = Settings.create rootFolder args |> printAndExit
        let mutable newContext = Context.createContext rootFolder settings args context      
        if newContext.BuildTasks.CleanOutputDir then
            CleanDir newContext.Settings.BuildOutput
        for (step, desc) in buildSteps do
            printHeader desc
            newContext <- step(newContext)
        newContext

    let fileWatcher (rootFolder : RootDirectory) (context : Context) = 
        let watchChanges (changes : seq<FileChange>) = 
            for c in changes do
                printVerbose "%s was changed." c.FullPath
                let fi = fileInfo c.FullPath
                match fi.Attributes.HasFlag FileAttributes.Hidden || fi.Attributes.HasFlag FileAttributes.Directory with
                | true -> ()
                | _ -> 
                    match fi.Extension with
                    | ".css" | ".scss" -> generateCss context |> ignore
                    | ".hbs" | ".md" | _ -> 
                        // Todo: In case of md there in no need to rebuild the whole site 
                        build rootFolder (Some context) context.CommandLineArgs |> ignore
                    Server.refreshEvent.Trigger()
        !!(rootFolder.Path + "/**/*.*") |> WatchChanges watchChanges
    
    /// Overall entry point for building a website
    let buildSite (args : string []) = 
        let cmdArgs = 
            args
            |> CommandLineParser.parseArgs
            |> returnOrFail
        
        let rootFolder = 
            cmdArgs.Docs
            |> RootDirectory.Create
            |> printAndExit
        
        let context = build rootFolder None cmdArgs
        if context.BuildTasks.Serve then Server.startWebServer context.Settings.BuildOutput
        if context.BuildTasks.Watch then 
            fileWatcher rootFolder context |> ignore
        // Only wait for input in case server is started
        if context.BuildTasks.Watch || context.BuildTasks.Serve then
            Console.ReadKey() |> ignore

